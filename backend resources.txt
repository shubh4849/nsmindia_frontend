Backend Endpoints:

---
### Routes
---

#### `src/routes/v1/file.route.js`
```javascript
const express = require('express');
const validate = require('../../middlewares/validate');
const fileValidation = require('../../validations/file.validation');
const fileController = require('../../controllers/file.controller');
const multer = require('multer');
const {fileTypes} = require('../../constants');
const router = express.Router();
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
  fileFilter: (req, file, cb) => {
    if (fileTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('File type not supported'), false);
    }
  },
});
router.post('/upload', upload.single('file'), fileController.uploadFile);

router.route('/').get(fileController.getFiles);

// Specific routes must be declared before generic parameterized routes
router.get('/search', fileController.searchFiles);
router.get('/count', fileController.getTotalFiles); // New route for total files count

router
  .route('/:fileId')
  .get(validate(fileValidation.getFile), fileController.getFile)
  .patch(validate(fileValidation.updateFile), fileController.updateFile)
  .delete(validate(fileValidation.deleteFile), fileController.deleteFile);

router.get('/:fileId/download', validate(fileValidation.getFile), fileController.downloadFile);
router.get('/:fileId/preview', validate(fileValidation.getFile), fileController.previewFile);

module.exports = router;
```

#### `src/routes/v1/folder.route.js`
```javascript
const express = require('express');
const validate = require('../../middlewares/validate');
const folderValidation = require('../../validations/folder.validation');
const folderController = require('../../controllers/folder.controller');

const router = express.Router();

router
  .route('/')
  .post(validate(folderValidation.createFolder), folderController.createFolder)
  .get(folderController.getFolders);

// Specific routes must be declared before generic parameterized routes
router.get('/tree', folderController.getFolderTree);
router.get('/count', folderController.getTotalFolders); // New route for total folders count

router
  .route('/:folderId')
  .get(validate(folderValidation.getFolder), folderController.getFolder)
  .patch(validate(folderValidation.updateFolder), folderController.updateFolder)
  .delete(validate(folderValidation.deleteFolder), folderController.deleteFolder);

router.get('/:folderId/contents', validate(folderValidation.getFolder), folderController.getFolderContents);
router.get('/:folderId/breadcrumb', validate(folderValidation.getFolder), folderController.getFolderBreadcrumb);
router.get('/:folderId/filtered', validate(folderValidation.getFolder), folderController.getFilteredFolderContents);

// New routes for direct child counts
router.get(
  '/:folderId/child-folders/count',
  validate(folderValidation.getFolder),
  folderController.getDirectChildFoldersCount
);
router.get(
  '/:folderId/child-files/count',
  validate(folderValidation.getFolder),
  folderController.getDirectChildFilesCount
);

module.exports = router;
```

#### `src/routes/v1/sse.route.js`
```javascript
const express = require('express');
const sseController = require('../../controllers/sse.controller');

const router = express.Router();

router.get('/upload-progress/:uploadId', sseController.getUploadProgress);
router.get('/folder-updates/:folderId', sseController.getFolderUpdates);

module.exports = router;
```

---
### Validations
---

#### `src/validations/file.validation.js`
```javascript
const Joi = require('joi');
const {objectId} = require('./custom.validation');

const createFile = {
  body: Joi.object().keys({
    name: Joi.string().required(),
    originalName: Joi.string().required(),
    filePath: Joi.string().required(),
    fileSize: Joi.number().required(),
    mimeType: Joi.string().required(),
    folderId: Joi.string().custom(objectId).required(),
    description: Joi.string(),
  }),
};

const getFile = {
  params: Joi.object().keys({
    fileId: Joi.string().custom(objectId),
  }),
};

const updateFile = {
  params: Joi.object().keys({
    fileId: Joi.required().custom(objectId),
  }),
  body: Joi.object().keys({
    name: Joi.string(),
    description: Joi.string(),
  }).min(1),
};

const deleteFile = {
  params: Joi.object().keys({
    fileId: Joi.string().custom(objectId),
  }),
};

const searchFiles = {
  query: Joi.object().keys({
    q: Joi.string(),
    folderId: Joi.string().custom(objectId),
    type: Joi.string(),
    name: Joi.string(),
    description: Joi.string(),
    dateFrom: Joi.string(),
    dateTo: Joi.string(),
    sortBy: Joi.string(),
    limit: Joi.number().integer().min(1).max(100).default(10),
    page: Joi.number().integer().min(1).default(1),
  }),
};

const getFiles = {
  query: Joi.object().keys({
    folderId: Joi.string().custom(objectId),
    name: Joi.string(),
    description: Joi.string(),
    dateFrom: Joi.string(),
    dateTo: Joi.string(),
    sortBy: Joi.string(),
    limit: Joi.number().integer().min(1).default(1),
    page: Joi.number().integer().min(1).default(1),
  }),
};

module.exports = {
  createFile,
  getFile,
  updateFile,
  deleteFile,
  searchFiles,
  getFiles,
};
```

#### `src/validations/folder.validation.js`
```javascript
const Joi = require('joi');
const {objectId} = require('./custom.validation');

const createFolder = {
  body: Joi.object().keys({
    name: Joi.string().required(),
    parentId: Joi.string().custom(objectId),
    description: Joi.string(),
    path: Joi.string().required(),
  }),
};

const getFolder = {
  params: Joi.object().keys({
    folderId: Joi.string().custom(objectId),
  }),
};

const updateFolder = {
  params: Joi.object().keys({
    folderId: Joi.required().custom(objectId),
  }),
  body: Joi.object().keys({
    name: Joi.string(),
    parentId: Joi.string().custom(objectId),
    description: Joi.string(),
    path: Joi.string(),
  }).min(1),
};

const deleteFolder = {
  params: Joi.object().keys({
    folderId: Joi.string().custom(objectId),
  }),
};

const getFolders = {
  query: Joi.object().keys({
    name: Joi.string(),
    parentId: Joi.string().custom(objectId).allow(null),
    sortBy: Joi.string(),
    limit: Joi.number().integer().min(1).default(1),
    page: Joi.number().integer().min(1).default(1),
  }),
};

module.exports = {
  createFolder,
  getFolder,
  updateFolder,
  deleteFolder,
  getFolders,
};
```

---
### Controllers
---

#### `src/controllers/file.controller.js`
```javascript
const httpStatus = require('http-status');
const pick = require('../utils/pick');
const ApiError = require('../utils/ApiError');
const catchAsync = require('../utils/catchAsync');
const {fileService, progressService} = require('../services');
const uuid = require('uuid');
const {fileTypes, ALL_ALLOWED_FILE_TYPES} = require('../constants');
const {getPaginateConfig} = require('../utils/queryPHandler');

const uploadFile = catchAsync(async (req, res) => {
  const uploadId = uuid.v4();
  if (!req.file) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'No file uploaded');
  }
  if (!fileTypes.includes(req.file.mimetype)) {
    throw new ApiError(
      httpStatus.UNSUPPORTED_MEDIA_TYPE,
      `File type ${req.file.mimetype} is not supported. Allowed types: ${ALL_ALLOWED_FILE_TYPES.join(', ')}`
    );
  }
  const file = await fileService.createFile({
    buffer: req.file.buffer,
    originalName: req.file.originalname,
    mimeType: req.file.mimetype,
    fileSize: req.file.size,
    folderId: req.body.folderId,
  });

  await progressService.updateUploadProgress(uploadId, req.file.size, req.file.size);

  res.status(httpStatus.CREATED).send({uploadId, fileId: file._id});
});

const getFiles = catchAsync(async (req, res) => {
  const {filters, options} = getPaginateConfig(req.query);
  const result = await fileService.queryFiles(filters, options);
  res.send(result);
});

const getFile = catchAsync(async (req, res) => {
  const file = await fileService.getFileById(req.params.fileId);
  if (!file) {
    throw new ApiError(httpStatus.NOT_FOUND, 'File not found');
  }
  res.send(file);
});

const downloadFile = catchAsync(async (req, res) => {
  const file = await fileService.getFileById(req.params.fileId);
  if (!file) {
    throw new ApiError(httpStatus.NOT_FOUND, 'File not found');
  }
  res.redirect(file.filePath);
});

const previewFile = catchAsync(async (req, res) => {
  const file = await fileService.getFileById(req.params.fileId);
  if (!file) {
    throw new ApiError(httpStatus.NOT_FOUND, 'File not found');
  }
  res.redirect(file.filePath);
});

const updateFile = catchAsync(async (req, res) => {
  const file = await fileService.updateFileById(req.params.fileId, req.body);
  res.send(file);
});

const deleteFile = catchAsync(async (req, res) => {
  await fileService.deleteFileById(req.params.fileId);
  res.status(httpStatus.NO_CONTENT).send();
});

const searchFiles = catchAsync(async (req, res) => {
  const {q, ...otherQuery} = req.query;
  const {filters, options} = getPaginateConfig(otherQuery);

  const result = await fileService.getFilteredFiles({
    q,
    ...filters,
  }, options);

  res.json(result);
});

const getTotalFiles = catchAsync(async (req, res) => {
  const count = await fileService.getTotalFilesCount();
  res.status(httpStatus.OK).send({count});
});

module.exports = {
  uploadFile,
  getFiles,
  getFile,
  downloadFile,
  previewFile,
  updateFile,
  deleteFile,
  searchFiles,
  getTotalFiles,
};
```

#### `src/controllers/folder.controller.js`
```javascript
const httpStatus = require('http-status');
const pick = require('../utils/pick');
const ApiError = require('../utils/ApiError');
const catchAsync = require('../utils/catchAsync');
const {folderService, fileService} = require('../services');
const {getPaginateConfig} = require('../utils/queryPHandler');

const createFolder = catchAsync(async (req, res) => {
  const folder = await folderService.createFolder(req.body);
  res.status(httpStatus.CREATED).send(folder);
});

const getFolders = catchAsync(async (req, res) => {
  const {filters, options} = getPaginateConfig(req.query);
  const result = await folderService.queryFolders(filters, options);
  res.send(result);
});

const getFolder = catchAsync(async (req, res) => {
  const folder = await folderService.getFolderById(req.params.folderId);
  if (!folder) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Folder not found');
  }
  res.send(folder);
});

const updateFolder = catchAsync(async (req, res) => {
  const folder = await folderService.updateFolderById(req.params.folderId, req.body);
  res.send(folder);
});

const deleteFolder = catchAsync(async (req, res) => {
  await folderService.cascadeDeleteFolder(req.params.folderId);
  res.status(httpStatus.NO_CONTENT).send();
});

const getFolderTree = catchAsync(async (req, res) => {
  const folders = await folderService.getAllFolders();
  const tree = folderService.buildTree(folders);
  res.send(tree);
});

const getFolderContents = catchAsync(async (req, res) => {
  const {page = 1, limit = 10, name, description, dateFrom, dateTo} = req.query;
  const folders = await folderService.getFoldersByParentId(req.params.folderId);
  const {files, totalFiles} = await fileService.getFilesByFolderId(
    req.params.folderId,
    {name, description, dateFrom, dateTo},
    {page, limit}
  );

  res.json({
    folders,
    files,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit),
      totalFolders: folders.length,
      totalFiles: totalFiles,
      totalPagesFolders: Math.ceil(folders.length / limit),
      totalPagesFiles: Math.ceil(totalFiles / limit),
    },
  });
});

const getFolderBreadcrumb = catchAsync(async (req, res) => {
  const breadcrumb = await folderService.getFolderBreadcrumb(req.params.folderId);
  res.send(breadcrumb);
});

const getFilteredFolderContents = catchAsync(async (req, res) => {
  const {folderId} = req.params;
  const {q, type, dateFrom, dateTo, name, description, page = 1, limit = 10} = req.query;

  const folders = await folderService.getFoldersByParentId(folderId);
  const {files, totalFiles} = await fileService.getFilteredFiles({
    folderId,
    q,
    type,
    dateFrom,
    dateTo,
    name,
    description,
  }, {page, limit});

  res.json({
    folders,
    files,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit),
      totalFolders: folders.length,
      totalFiles: totalFiles,
      totalPagesFiles: Math.ceil(totalFiles / limit),
    },
  });
});

const getTotalFolders = catchAsync(async (req, res) => {
  const count = await folderService.getTotalFoldersCount();
  res.status(httpStatus.OK).send({count});
});

const getDirectChildFoldersCount = catchAsync(async (req, res) => {
  const {folderId} = req.params;
  const count = await folderService.countChildFolders(folderId);
  res.status(httpStatus.OK).send({count});
});

const getDirectChildFilesCount = catchAsync(async (req, res) => {
  const {folderId} = req.params;
  const count = await fileService.countChildFiles(folderId);
  res.status(httpStatus.OK).send({count});
});

module.exports = {
  createFolder,
  getFolders,
  getFolder,
  updateFolder,
  deleteFolder,
  getFolderTree,
  getFolderContents,
  getFolderBreadcrumb,
  getFilteredFolderContents,
  getTotalFolders,
};

module.exports.getDirectChildFoldersCount = getDirectChildFoldersCount;
module.exports.getDirectChildFilesCount = getDirectChildFilesCount;
```

#### `src/controllers/sse.controller.js`
```javascript
const httpStatus = require('http-status');
const catchAsync = require('../utils/catchAsync');
const {progressService, sseService} = require('../services');

const getUploadProgress = catchAsync(async (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    Connection: 'keep-alive',
    'Access-Control-Allow-Origin': '*',
  });

  const {uploadId} = req.params;
  const sendProgress = data => {
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  const interval = setInterval(async () => {
    const progress = await progressService.getUploadProgressById(uploadId);
    if (progress) {
      sendProgress({
        progress: progress.progress,
        status: progress.status,
        fileName: progress.fileName,
      });

      if (progress.status === 'completed' || progress.status === 'failed') {
        clearInterval(interval);
        await progressService.cleanupUploadProgress(uploadId);
        res.end();
      }
    } else {
      clearInterval(interval);
      res.end();
    }
  }, 1000);

  req.on('close', () => {
    clearInterval(interval);
    res.end();
  });
});

const getFolderUpdates = catchAsync(async (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    Connection: 'keep-alive',
    'Access-Control-Allow-Origin': '*',
  });

  const {folderId} = req.params;

  const changeStream = sseService.getFolderChangeStream(folderId);

  changeStream.on('change', change => {
    res.write(`event: folderUpdate\ndata: ${JSON.stringify(change.fullDocument)}\n\n`);
  });

  req.on('close', () => {
    changeStream.close();
    res.end();
  });
});

module.exports = {
  getUploadProgress,
  getFolderUpdates,
};
```

---
### Services
---

#### `src/services/folder.service.js`
```javascript
const httpStatus = require('http-status');
const {Folder, File} = require('../models');
const ApiError = require('../utils/ApiError');

const buildTree = (folders, parentId = null) => {
  const folderTree = [];
  folders.forEach(folder => {
    if (folder.parentId === parentId) {
      const children = buildTree(folders, folder._id);
      if (children.length > 0) {
        folder.children = children;
      }
      folderTree.push(folder);
    }
  });
  return folderTree;
};

const createFolder = async folderBody => {
  if (await Folder.isNameTaken(folderBody.name, folderBody.parentId)) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Folder with this name already exists in the parent folder');
  }
  return Folder.create(folderBody);
};

const queryFolders = async (filter, options) => {
  let query = {};

  if (filter.name) {
    query.name = new RegExp(filter.name, 'i');
  }
  if (filter.parentId === null || filter.parentId === undefined) {
    query.parentId = null;
  } else if (filter.parentId) {
    query.parentId = filter.parentId;
  }

  return Folder.paginate(query, options);
};

const getFolderById = async id => Folder.findById(id);

const updateFolderById = async (folderId, updateBody) => {
  const folder = await getFolderById(folderId);
  if (!folder) throw new ApiError(httpStatus.NOT_FOUND, 'Folder not found');
  if (updateBody.name && (await Folder.isNameTaken(updateBody.name, folder.parentId, folderId))) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Folder with this name already exists in the parent folder');
  }
  Object.assign(folder, updateBody);
  await folder.save();
  return folder;
};

const deleteFolderById = async folderId => {
  const folder = await getFolderById(folderId);
  if (!folder) throw new ApiError(httpStatus.NOT_FOUND, 'Folder not found');
  await folder.remove();
  return folder;
};

const getFolderBreadcrumb = async folderId => {
  const breadcrumb = await Folder.aggregate([
    {$match: {_id: folderId}},
    {
      $graphLookup: {
        from: 'folders',
        startWith: '$parentId',
        connectFromField: 'parentId',
        connectToField: '_id',
        as: 'path',
        maxDepth: 10,
      },
    },
    {$unwind: '$path'},
    {$project: {_id: '$path._id', name: '$path.name', parentId: '$path.parentId'}},
    {$sort: {'path._id': 1}},
  ]);
  return breadcrumb;
};

const cascadeDeleteFolder = async folderId => {
  const foldersToDelete = [folderId];
  let currentFolders = [folderId];
  while (currentFolders.length > 0) {
    const childFolders = await Folder.find({parentId: {$in: currentFolders}}).select('_id');
    const childFiles = await File.find({folderId: {$in: currentFolders}}).select('_id');

    if (childFolders.length > 0) {
      const childFolderIds = childFolders.map(folder => folder._id);
      foldersToDelete.push(...childFolderIds);
      currentFolders = childFolderIds;
    } else {
      currentFolders = [];
    }

    if (childFiles.length > 0) {
      const childFileIds = childFiles.map(file => file._id);
      await File.deleteMany({_id: {$in: childFileIds}});
    }
  }
  await Folder.deleteMany({_id: {$in: foldersToDelete}});
};

const getAllFolders = async () => Folder.find().select('_id name parentId path');
const getFoldersByParentId = async parentId => Folder.find({parentId});
const getTotalFoldersCount = async () => Folder.countDocuments();
const countChildFolders = async parentId => Folder.countDocuments({parentId});

module.exports = {
  buildTree,
  createFolder,
  queryFolders,
  getFolderById,
  updateFolderById,
  deleteFolderById,
  getFolderBreadcrumb,
  cascadeDeleteFolder,
  getAllFolders,
  getFoldersByParentId,
  getTotalFoldersCount,
  countChildFolders,
};
```

#### `src/services/file.service.js`
```javascript
const httpStatus = require('http-status');
const {File} = require('../models');
const ApiError = require('../utils/ApiError');
const {fileUploadService} = require('../microservices');

const createFile = async ({buffer, originalName, mimeType, fileSize, folderId}) => {
  const uploadResult = await fileUploadService.uploadFileToCloudinary(buffer, `files/${folderId || 'root'}`, originalName);
  const fileBody = {
    name: uploadResult.original_filename || originalName,
    originalName,
    filePath: uploadResult.secure_url,
    fileSize,
    mimeType,
    folderId,
  };
  return File.create(fileBody);
};

// Paginated query
const queryFiles = async (filters, options) => {
  const mongoFilters = {};
  if (filters.name) mongoFilters.name = new RegExp(filters.name, 'i');
  if (filters.description) mongoFilters.description = new RegExp(filters.description, 'i');
  if (filters.folderId) mongoFilters.folderId = filters.folderId;
  if (filters.mimeType) mongoFilters.mimeType = new RegExp(filters.mimeType, 'i');
  if (filters.dateFrom || filters.dateTo) {
    mongoFilters.createdAt = {};
    if (filters.dateFrom) mongoFilters.createdAt.$gte = new Date(filters.dateFrom);
    if (filters.dateTo) mongoFilters.createdAt.$lte = new Date(filters.dateTo);
  }
  return File.paginate(mongoFilters, options || {});
};

const getFileById = async id => File.findById(id);

const updateFileById = async (fileId, updateBody) => {
  const file = await getFileById(fileId);
  if (!file) throw new ApiError(httpStatus.NOT_FOUND, 'File not found');
  Object.assign(file, updateBody);
  await file.save();
  return file;
};

const deleteFileById = async fileId => {
  const file = await getFileById(fileId);
  if (!file) throw new ApiError(httpStatus.NOT_FOUND, 'File not found');
  const cloudinaryPublicId = file.filePath.split('/').pop().split('.')[0];
  await fileUploadService.deleteFileFromCloudinary(cloudinaryPublicId);
  await file.remove();
  return file;
};

const getFilesByFolderId = async (folderId, filterParams = {}, options = {}) => {
  return getFilteredFiles({...filterParams, folderId}, options);
};

// Filtered paginated query (supports q/name/description/type/date range)
const getFilteredFiles = async (filter, options) => {
  let query = {};
  if (filter.folderId) query.folderId = filter.folderId;
  if (filter.q) {
    query.$text = {$search: filter.q};
  } else {
    if (filter.name) query.name = new RegExp(filter.name, 'i');
    if (filter.description) query.description = new RegExp(filter.description, 'i');
  }
  if (filter.type) query.mimeType = new RegExp(filter.type, 'i');
  if (filter.dateFrom || filter.dateTo) {
    query.createdAt = {};
    if (filter.dateFrom) query.createdAt.$gte = new Date(filter.dateFrom);
    if (filter.dateTo) query.createdAt.$lte = new Date(filter.dateTo);
  }
  return File.paginate(query, options || {});
};

const getTotalFilesCount = async () => File.countDocuments();
const countChildFiles = async folderId => File.countDocuments({folderId});

module.exports = {
  createFile,
  queryFiles,
  getFileById,
  updateFileById,
  deleteFileById,
  getFilesByFolderId,
  getFilteredFiles,
  getTotalFilesCount,
  countChildFiles,
};
```

#### `src/services/progress.service.js`
```javascript
const {UploadProgress} = require('../models');

const updateUploadProgress = async (uploadId, uploadedBytes, totalBytes) => {
  const progress = (uploadedBytes / totalBytes) * 100;
  const status = progress === 100 ? 'completed' : 'uploading';
  return UploadProgress.findByIdAndUpdate(
    uploadId,
    {uploadedBytes, progress, status, updatedAt: Date.now()},
    {new: true, upsert: true}
  );
};

const getUploadProgressById = async uploadId => UploadProgress.findById(uploadId);

const cleanupUploadProgress = async uploadId => {
  await UploadProgress.findByIdAndDelete(uploadId);
};

module.exports = {
  updateUploadProgress,
  getUploadProgressById,
  cleanupUploadProgress,
};
```

#### `src/services/sse.service.js`
```javascript
const {Folder} = require('../models');

const getFolderChangeStream = folderId => {
  return Folder.watch([
    {$match: {'fullDocument.parentId': folderId}},
    {$match: {operationType: {$in: ['insert', 'update', 'delete']}}},
  ]);
};

module.exports = {
  getFolderChangeStream,
};
```

#### `src/services/index.js`
```javascript
module.exports.userService = require('./user.service');
module.exports.authService = require('./auth.service');
module.exports.folderService = require('./folder.service');
module.exports.fileService = require('./file.service');
module.exports.progressService = require('./progress.service');
module.exports.sseService = require('./sse.service');
module.exports.fileUploadService = require('../microservices/fileUpload.service');
```

---
### Microservices
---

#### `src/microservices/fileUpload.service.js`
```javascript
const cloudinary = require('cloudinary').v2;
const config = require('../config/config');

cloudinary.config({
  cloud_name: config.cloudinary.cloudName,
  api_key: config.cloudinary.apiKey,
  api_secret: config.cloudinary.apiSecret,
  secure: true,
});

const uploadFileToCloudinary = async (fileBuffer, folder, originalName) => {
  return new Promise((resolve, reject) => {
    cloudinary.uploader.upload_stream(
      {
        resource_type: 'auto',
        folder: folder,
        public_id: originalName.split('.')[0],
      },
      (error, result) => {
        if (error) return reject(error);
        resolve(result);
      }
    ).end(fileBuffer);
  });
};

const deleteFileFromCloudinary = async publicId => cloudinary.uploader.destroy(publicId);

module.exports = {
  uploadFileToCloudinary,
  deleteFileFromCloudinary,
};
```

#### `src/microservices/index.js`
```javascript
module.exports.fileUploadService = require('./fileUpload.service');
module.exports.notificationService = require('./notification.service');
module.exports.smsService = require('./sms.service');
```

---
### Models
---

#### `src/models/file.model.js`
```javascript
const mongoose = require('mongoose');
const {paginate} = require('./plugins/paginate');

const fileSchema = new mongoose.Schema({
  name: {type: String, required: true, trim: true},
  originalName: {type: String, required: true, trim: true},
  filePath: {type: String, required: true, trim: true},
  fileSize: {type: Number, required: true},
  mimeType: {type: String, required: true},
  folderId: {type: mongoose.Schema.Types.ObjectId, ref: 'Folder'},
  description: {type: String, trim: true},
  createdAt: {type: Date, default: Date.now},
  updatedAt: {type: Date, default: Date.now},
});

fileSchema.index({folderId: 1});
fileSchema.index({name: 1});
fileSchema.index({name: 'text', description: 'text'});

fileSchema.plugin(paginate);

const File = mongoose.model('File', fileSchema);
module.exports = File;
```

#### `src/models/folder.model.js`
```javascript
const mongoose = require('mongoose');
const {paginate} = require('./plugins/paginate');

const folderSchema = new mongoose.Schema({
  name: {type: String, required: true, trim: true},
  parentId: {type: mongoose.Schema.Types.ObjectId, ref: 'Folder', default: null},
  path: {type: String, required: true, trim: true},
  description: {type: String, trim: true},
  createdAt: {type: Date, default: Date.now},
  updatedAt: {type: Date, default: Date.now},
});

folderSchema.index({parentId: 1});
folderSchema.index({path: 1});

folderSchema.plugin(paginate);

folderSchema.statics.isNameTaken = async function(name, parentId, excludeFolderId) {
  const folder = await this.findOne({name, parentId, _id: {$ne: excludeFolderId}});
  return !!folder;
};

const Folder = mongoose.model('Folder', folderSchema);
module.exports = Folder;
```

#### `src/models/uploadprogress.model.js`
```javascript
const mongoose = require('mongoose');
const {paginate} = require('./plugins/paginate');

const uploadProgressSchema = new mongoose.Schema({
  _id: {type: String, required: true},
  fileName: {type: String, required: true, trim: true},
  progress: {type: Number, default: 0},
  status: {type: String, enum: ['uploading', 'completed', 'failed'], default: 'uploading'},
  fileSize: {type: Number},
  uploadedBytes: {type: Number, default: 0},
  createdAt: {type: Date, default: Date.now},
  updatedAt: {type: Date, default: Date.now},
});

uploadProgressSchema.index({status: 1});

uploadProgressSchema.plugin(paginate);

const UploadProgress = mongoose.model('UploadProgress', uploadProgressSchema);
module.exports = UploadProgress;
```

#### `src/models/index.js`
```javascript
const {User, Client} = require('./user.model');
const Folder = require('./folder.model');
const File = require('./file.model');
const UploadProgress = require('./uploadprogress.model');

module.exports = { User, Client, Folder, File, UploadProgress };
```

---
### Constants
---

#### `src/constants/fileTypes.js`
```javascript
const IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/tiff'];
const DOCUMENT_TYPES = [
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.ms-powerpoint',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  'text/plain',
  'text/csv',
];
const ALL_ALLOWED_FILE_TYPES = [...IMAGE_TYPES, ...DOCUMENT_TYPES];
module.exports = { IMAGE_TYPES, DOCUMENT_TYPES, ALL_ALLOWED_FILE_TYPES };
```

#### `src/constants/index.js`
```javascript
const dbOptions = { page: 1, limit: 10, sortBy: 'createdAt', sortOrder: 'asc' };
const {ALL_ALLOWED_FILE_TYPES} = require('./fileTypes');
module.exports = { dbOptions, fileTypes: ALL_ALLOWED_FILE_TYPES };
```

---
### Middlewares
---

#### `src/middlewares/upload.js`
```javascript
const multer = require('multer');
const {fileTypes} = require('../constants');
const ApiError = require('../utils/ApiError');
const httpStatus = require('http-status');

const storage = multer.memoryStorage();

const fileFilter = (req, file, cb) => {
  if (fileTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new ApiError(httpStatus.BAD_REQUEST, 'Invalid file type.'), false);
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: 10 * 1024 * 1024 },
});

module.exports = upload;
```

---
### Utilities
---

#### `src/utils/queryPHandler.js`
```javascript
const getPaginateConfig = queryParams => {
  const {page = 1, limit = 10, sortBy = 'createdAt', sortOrder = 'desc', ...filters} = queryParams;
  const options = {page, limit, sortBy, sortOrder};
  return {filters, options};
};

module.exports = { getPaginateConfig };
```

